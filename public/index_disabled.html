<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Force Layout Playground</title>
    <script src="d3.v3.js"></script>
    <script src="deepCopy.js"></script>
    <script src="jsnetworkx-custom.js"></script>
    <style>
        body {
            font: 13px sans-serif;
            position: relative;
            width: 960px;
            height: 500px;
        }
        .node {
            cursor: crosshair;
        }
        .link {
            stroke: #000;
            stroke-width: 5;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            width: 120px;
            height: 55px;
            padding: 2px;
            font: 15px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }

    </style>
</head>
<body>
<div id="vaccinate">
    <input name="vaccinateButton"
           type="button"
           value="Vaccinate!"
           onclick="vaccinate()" />
</div>

<div id="subStrat">
    <input name="submitStrategyButton"
           type="button"
           value="Submit Strategy"
           onclick="subStrat()" />
</div>



<script type="text/javascript">
var preVaccination  = true;
var sizeByDegree    = false;
var submitted       = false;
var sizeByBC        = false;
var twine = [];
var twineIndex = 0;
var numberOfCommunities = null;
var G = jsnx.Graph();
var bcScores = [];

function toggleSizeByBC() {
    sizeByBC = !sizeByBC;
    combinedUpdate();
}


// make graph object
// nodes are basic individuals with IDs from 0-19
// edges/links are in JSON format.  Note that prior node IDs must match link IDs
var graph = {
    nodes: [{id:0, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null}, {id:1, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null}, {id:2, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:3, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:4, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:5, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:6, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:7, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null},{id:8, status:0, group:null, edges:[], marked:false, degree:null, bcScore:null}],
    links: [{source:0,target:1, id:null},{source:0,target:2, id:null},{source:1,target:2, id:null},{source:1,target:3, id:null},{source:2,target:3, id:null},{source:2,target:4, id:null},{source:3,target:4, id:null},{source:3,target:6, id:null},{source:4,target:7, id:null}]
};


function convertGraphForNetX() {
    var vertices = [];
    var edges = [];
    var G = jsnx.Graph();

    for (var node = 0; node < graph.nodes.length; node++) {
        vertices.push(graph.nodes[node].id);
    }

    for (var edge = 0; edge < graph.links.length; edge++) {
        var formatted = [];
        formatted.push(graph.links[edge].source.id);
        formatted.push(graph.links[edge].target.id);
        edges.push(formatted);
    }

    G.add_nodes_from(vertices);
    G.add_edges_from(edges);

    this.G = G;
}

function computeBetweennessCentrality() {
    var bc = jsnx.betweenness_centrality(G);
    var bcScores = [];
    for (var i = 0; i < graph.nodes.length; i++) {
        bcScores[i] = bc[i];
    }

    return bcScores;

}


function computeShortestPath(source, target, G) {
    var shortestDistance = Math.POSITIVE_INFINITY;
    var shortestPath = jsnx.bidirectional_shortest_path(G,source,target);
    shortestDistance = shortestPath.length - 1;

    return shortestPath;
}

//links: [{source:0,target:1, id:null},{source:0,target:2, id:null},{source:1,target:2, id:null},{source:1,target:3, id:null},{source:2,target:3, id:null},{source:2,target:4, id:null},{source:4,target:5, id:null},{source:3,target:4, id:null},{source:3,target:6, id:null},{source:6,target:8, id:null},{source:7,target:8, id:null},{source:4,target:7, id:null}]


assignEdgesForAllNodes();

var groupCounter = 0;
//assignCommunities();

var originalGraph = owl.deepCopy(graph);

// select "body" section, and append an empty SVG with height and width values
var width = 800,
        height = 600,
        svg;
svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("weight", height);

// initialize force layout. point to nodes & links.  size based on prior height and width.  set particle charge. setup step-wise force settling.
var force = d3.layout.force()
        .nodes(graph.nodes)
        .links(graph.links)
        .size([width, height])
        .charge(-1000)
        .on("tick", tick)
        .start();

// associate empty SVGs with link data. assign attributes.
var link = svg.selectAll(".link")
        .data(graph.links)
        .enter().append("line")
        .attr("class", "link");

// associate empty SVGs with node data. assign attributes. call force.drag to make them moveable.
var node = svg.selectAll(".node")
        .data(graph.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", metric)
        .style("fill", color)
        .on("mouseover", function(d) {
            div.transition()
                    .duration(200)
                    .style("opacity", .9);
            div.html("NodeID:\t" + d.id + "<br/>" + "Neighbors:\t" +  degree(d) + "<br/>"  + "Centrality: ##")
                    .style("left", 500 + "px")
                    .style("top", 20 + "px");
        })
        .on("mouseout", function(d) {
            div.transition()
                    .duration(400)
                    .style("opacity", 0)})
        .call(force.drag)
        .on("click", click);

var div = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);




// tick function, which does the physics for each individual node & link.
function tick() {
    link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
}

function combinedUpdate() {
    bcScores = computeBetweennessCentrality();
    if (preVaccination) {
        updateNodeAttributes();
    }
    else {
        updateFullGraph();
        updateNodeAttributes();
    }
    preVaccination  = true;

}

function updateFullGraph() {
    bcScores = computeBetweennessCentrality();
    var nodes = filterNodes();
    var links = filterLinks();

    force
            .nodes(nodes)
            .links(links)
            .start();

    // select all links, join them with new data, and save it to "link" variable
    link = svg.selectAll("line.link")
            .data(links, function(d) { return d.source.id + "-" + d.target.id; });

    // enter new links (unnecessary at the moment)
    link.enter().insert("svg:line", ".node")
            .attr("class", "link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

    // Exit any old links.
    link.exit().remove();

    // Update the nodes…
    node = svg.selectAll("circle.node")
            .data(nodes, function(d) { return d.id; })
            .style("fill", color);

    // Enter any new nodes.
    node.enter().append("svg:circle")
            .attr("class", "node")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r", metric)
            .style("fill", color)
            .on("click", click)
            .call(force.drag);

    // Exit any old nodes.
    node.exit().remove();

    graph.nodes = nodes;
    graph.links = links;
}

function updateNodeAttributes() {
    force
            .nodes(graph.nodes)
            .links(graph.links)
            .start();

    // Update the nodes…
    node = svg.selectAll("circle.node")
            .data(graph.nodes, function(d) { return d.id; })
            .attr("r", metric)
            .style("fill", color);
}

function vaccinate() {
    preVaccination  = false;
    combinedUpdate();
    updateCommunities();
    convertGraphForNetX();
}

function degree(node) {
    var degree = 0;
    for (var i = 0; i < graph.links.length; i++) {
        if (graph.links[i].source == node || graph.links[i].target == node) degree++;
    }
    return degree;
}

function degreeSize(node) {
    var degSize = null;
    if (sizeByDegree == false) degSize = 8;
    if (sizeByDegree == true)  degSize = (degree(node) + 2) * 2.5;

    return degSize;
}

function toggleSizeByDegree() {
    sizeByDegree = !sizeByDegree;
    combinedUpdate();
}


function metric(node) {
    node.degree = degree(node);
    node.bcScore = bcScores[node.id];
    var sizeByMetric = 8;

    if (sizeByBC == true && sizeByDegree == false) sizeByMetric = (node.bcScore / 0.025) + 10;
    if (sizeByBC == false && sizeByDegree == true) sizeByMetric = (node.degree + 2) * 2.5;

    if (sizeByBC == true && sizeByDegree == true) sizeByMetric = ((node.bcScore / 0.01) + 1) + ((node.degree + 2) * 2.5) / 2;
    return sizeByMetric;
}

function filterNodes() {
    var nodes = [];
    for (var i = 0; i < graph.nodes.length; i++) {
        if (graph.nodes[i].status == 0) {
            nodes.push(graph.nodes[i]);
        }
    }
    return nodes;
}

function filterLinks() {
    var links = [];
    for (var i = 0; i < graph.links.length; i++) {
        if (graph.links[i].source.status == 0 && graph.links[i].target.status == 0) {
            links.push(graph.links[i]);
        }
    }
    return links;
}

function color(d) {
    var color = null;
    if (d.status == 0) color = "#ff0000";
    if (d.status == 1) color = "#c6dbef";
    return color;
}

function click(node) {
    if (node.status == 1) node.status = 0;
    else node.status = 1;

    for (var i = 0; i < originalGraph.nodes.length; i++) {
        if (originalGraph.nodes[i] == node) originalGraph.nodes[i].status = node.status;
    }

    combinedUpdate();
}


function findNeighbors(sampleNode) {
    var neighbors = [];
    for (var i = 0; i < graph.links.length; i++) {
        var testLink = graph.links[i];
        if (testLink.source == sampleNode) neighbors.push(testLink.target);
        if (testLink.target == sampleNode) neighbors.push(testLink.source);
    }
    return neighbors;
}


function subStrat() {
    updatePostVac();
}


function updatePostVac() {
    graph.nodes = originalGraph.nodes;
    graph.links = originalGraph.links;

    force
            .nodes(graph.nodes)
            .links(graph.links)
            .start();

    // select all links, join them with new data, and save it to "link" variable
    link = svg.selectAll("line.link")
            .data(graph.links, function(d) { return d.source.id + "-" + d.target.id; });

    // enter new links
    link.enter().insert("svg:line", ".node")
            .attr("class", "link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });


    // Update the nodes…
    node = svg.selectAll("circle.node")
            .data(graph.nodes, function(d) { return d.id; })
            .style("fill", color)
            .on("mouseover", function(d) {
                div.transition()
                        .duration(200)
                        .style("opacity", .9);
                div.html("NodeID:\t" + d.id + "<br/>" + "Neighbors:\t" +  degree(d) + "<br/>"  + "Centrality: ##")
                        .style("left", 500 + "px")
                        .style("top", 20 + "px");
            })
            .on("mouseout", function(d) {
                div.transition()
                        .duration(400)
                        .style("opacity", 0)});

    // Enter any new nodes.
    node.enter().append("svg:circle")
            .attr("class", "node")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r", metric)
            .style("fill", color)
            .on("mouseover", function(d) {
                div.transition()
                        .duration(200)
                        .style("opacity", .9);
                div.html("NodeID:\t" + d.id + "<br/>" + "Neighbors:\t" +  degree(d) + "<br/>"  + "Centrality: ##")
                        .style("left", 500 + "px")
                        .style("top", 20 + "px");
            })
            .on("mouseout", function(d) {
                div.transition()
                        .duration(400)
                        .style("opacity", 0)})
            .on("click", click)
            .call(force.drag);

        // Exit any old nodes.
        node.exit().remove();
    }

function assignEdgeIDs() {
    for (var id = 0; id < graph.links.length; id++) {
        var link = graph.links[id];
        link.id = id;
    }
}

function assignEdgesToNode(node) {
    var edges = [];
    for (var linkIndex = 0; linkIndex < graph.links.length; linkIndex++) {
        var link = graph.links[linkIndex];

        if (link.source == node.id || link.target == node.id) {
            edges.push(link.id);
        }
    }
    return edges;
}

function assignEdgesForAllNodes() {
    assignEdgeIDs();
    for (var nodeIndex = 0; nodeIndex < graph.nodes.length; nodeIndex++) {
        var node = graph.nodes[nodeIndex];
        node.edges = assignEdgesToNode(node);
    }
}

function markNode(node) {
    node.group = groupCounter;
}

function findLink(source, target) {
    var link = null;
    for (var i = 0; i < graph.links.length; i++) {
         if (graph.links[i].source == source && graph.links[i].target == target) link = graph.links[i];
         if (graph.links[i].target == source && graph.links[i].source == target) link = graph.links[i];
    }
    return link;
}












function getUnmarkedUngroupedNodes() {
    var unmarkedNodes = [];
    for (var nodeIndex = 0; nodeIndex < graph.nodes.length; nodeIndex++) {
        var node = graph.nodes[nodeIndex];

        if (node.marked == false) unmarkedNodes.push(node);
    }
    return unmarkedNodes;
}

function updateCommunities() {
    twine = [];
    twineIndex = 0;
    groupCounter = 1;
    for (var nodeIndex = 0; nodeIndex < graph.nodes.length; nodeIndex++) {
        var node = graph.nodes[nodeIndex];
        node.group = null;
        node.marked = false;
    }

    assignGroups();

}

function assignGroups() {
    while(true) {
        var unassigned = getUnmarkedUngroupedNodes();

        if (unassigned.length == 0) {
            numberOfCommunities = groupCounter - 1;
            break;
        }

        if (pacMan(unassigned[0]) && unassigned.length != 0) {
           groupCounter++;
        }

    }
}

function pacMan(node) {
    node.group = groupCounter;
    var nextNode = null;
    if (node != null && !node.marked) {
        node.marked = true;
        node.group = groupCounter;
        twine.push(node);
        var nodeDegree = degree(node);
        var neighbors = findNeighbors(node);
        for (var completionCounter = 0; completionCounter < nodeDegree; completionCounter++) {
            var nodeToCheck = neighbors[completionCounter];
            if (!nodeToCheck.marked) {
                nextNode = nodeToCheck;
                pacMan(nextNode);
            }
        }
    }
    if (node == null && twineIndex != 0) {
        twineIndex =- 1;
        nextNode = twine[twineIndex];
        pacMan(nextNode);
    }
    else {
        return true;
    }


}

convertGraphForNetX();
bcScores = computeBetweennessCentrality();




</script>
</body>
</html>